<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title></title>
<link crossorigin="anonymous" href="https://stackpath.bootstrapcdn.com/bootstrap/4.5.2/css/bootstrap.min.css"
    integrity="sha384-JcKb8q3iqJ61gNV9KGb8thSsNjpSL0n8PARn9HuZOnIxN0hoP+VmmDGMN5t9UJ0Z" rel="stylesheet" />
<script src="https://unpkg.com/html2canvas@1.4.1/dist/html2canvas.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/1.5.3/jspdf.debug.js"></script>
<style type="text/css">
    body {
        font-size: 0.875rem;
    }

    .container-fluid {
        max-width: 1920px;
        margin: 15px auto;
    }

    .chart-header {
        display: flex;
        align-items: flex-start;
    }

    .chart-header-icon {
        width: 45px;
        height: 45px;
        margin-top: 4px;
        margin-right: 8px;
    }

    .chart-title-main {
        font-size: 1.7rem;
        color: #00aaff;
        font-weight: bold;
    }

    .chart-intro {
        font-size: 1rem;
    }

    .chart-title-main span {
        font-weight: normal;
        font-style: italic;
    }

    .chart-title-sub,
    .chart-footer {
        font-size: 0.75rem;
    }

    .chart-title-sub,
    .chart-footer {
        color: #6c757d;
    }

    .btn__svg {
        text-align: left;
        text-indent: -9999px;
        font-size: 0;
        line-height: 0px;
        background-position: center center;
        background-repeat: no-repeat;
        background-size: contain;
        border: 0;
        background-color: transparent;
        height: 35px;
        width: 35px;
        padding: 0;
        margin-right: 5px;
        position: relative;
    }

    .btn__svg:hover::after {
        opacity: 1;
    }

    .btn__svg::after {
        background-position: center center;
        background-repeat: no-repeat;
        background-size: contain;
        content: "";
        display: block;
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        opacity: 0;
        -webkit-transition: opacity 0.1s cubic-bezier(0.3, 0.65, 0.72, 0.63);
        -o-transition: opacity 0.1s cubic-bezier(0.3, 0.65, 0.72, 0.63);
        transition: opacity 0.1s cubic-bezier(0.3, 0.65, 0.72, 0.63);
        background-color: #fff;
    }

    .btn__export--pdf {
        background-image: url(https://www.lhfatlas.org.uk/sites/default/files/images/pdf-black.png);
    }

    .btn__export--pdf::after {
        background-image: url(https://www.lhfatlas.org.uk/sites/default/files/images/pdf-blue.png);
    }

    .btn__export--csv {
        background-image: url(https://www.lhfatlas.org.uk/sites/default/files/images/csv-black.png);
    }

    .btn__export--csv::after {
        background-image: url(https://www.lhfatlas.org.uk/sites/default/files/images/csv-blue.png);
    }

    .btn__copy {
        background-image: url(https://www.lhfatlas.org.uk/sites/default/files/images/url-black.png);
    }

    .btn__copy::after {
        background-image: url(https://www.lhfatlas.org.uk/sites/default/files/images/url-blue.png);
    }

    .chart-tooltip {
        position: fixed;
        top: 0;
        left: 0;
        pointer-events: none;
        background-color: rgba(255, 255, 255, 0.9);
        border: 1px solid rgba(0, 0, 0, 0.125);
        border-radius: 0.25rem;
        padding: 0.75rem 1.25rem;
        max-width: 100vw;
        opacity: 0;
        transition: opacity 0.15s linear;
    }

    .chart-tooltip p {
        margin-bottom: 0.5rem;
    }

    .chart-tooltip p:last-of-type {
        margin-bottom: 0;
    }

    .chart-tooltip.show {
        opacity: 1;
    }

    @media (prefers-reduced-motion: reduce) {
        .chart-tooltip {
            transition: none;
        }
    }

    @media (min-width: 600px) {
        .chart-tooltip {
            max-width: 600px;
        }
    }

    .service-types .card {
        border: 1px solid #fff;
    }

    .service-types .card.active {
        border-color: #4e79a8;
    }

    .service-types .card .service-type-title {
        cursor: pointer;
        color: #00aaff;
    }

    .service-types .card .service-type-title:hover,
    .service-types .card.active .service-type-title {
        font-weight: bold;
    }

    .service-types .card.active .service-type-title {
        cursor: initial;
    }

    .service-types .card .service-tile {
        width: 10px;
        height: 10px;
        margin-right: 5px;
        background-color: #bab0ac;
    }

    .service-types .card.active .service-tile {
        background-color: #4e79a8;
    }

    .service-types .card .service-tile.muted {
        opacity: 0.2;
    }

    .service-map .service-map-title {
        color: #00aaff;
        font-weight: bold;
    }

    .service-map svg {
        display: block;
    }

    .service-map .map-path {
        stroke: #6c757d;
        stroke-width: 0.5;
    }

    .service-map .map-path.muted {
        opacity: 0.2;
    }

    .service-map .map-path.highlighted {
        stroke: #FFA500;
        /* or any color you prefer for highlighting */
        stroke-width: 4px;
        /* the width of the highlight */
        stroke-opacity: 1;
        /* ensure the stroke is fully opaque */
    }

    .service-map .legend-title {
        color: #00aaff;
    }

    .service-map .legend-item {
        width: 50px;
        height: 20px;
        border: 1px solid #6c757d;
    }

    .service-map .legend-item+.legend-item {
        border-left: none;
    }

    .service-map .legend-item:nth-last-child(1),
    .service-map .legend-item:nth-last-child(2) {
        color: #fff;
    }

    .service-list .service-list-title {
        color: #00aaff;
        font-weight: bold;
    }

    .map-label,
    .bar-value {
        fill: currentColor;
        font-weight: bold;
        stroke: #fff;
        stroke-width: 3px;
        stroke-linecap: round;
        stroke-linejoin: round;
        paint-order: stroke;
    }

    .service-list tr.muted {
        opacity: 1;
    }

    .chart-tooltip .service-name,
    .chart-tooltip .borough-name {
        font-size: 1rem;
        font-weight: bold;
        color: #00aaff;
    }

    .chart-tooltip .service-capacity {
        color: #ff4e80;
        font-weight: bold;
    }

    .chart-tooltip span {
        color: #4e79a8;
    }

    .rowq {
        display: flex;
        justify-content: space-around;
        padding: 3px 0;
        /* Adjust top and bottom padding */
    }

    .column {
        display: flex;
        flex-direction: column;
        justify-content: space-around;
        flex: 1;
        /* Make each column take up equal width */
    }

    .top {
        font-size: 34px;
        color: #00aaff;
        /* Large font size for the numbers */
        font-weight: bold;
        /* Make the number bold */
        padding: 0;
        /* Adjust top and bottom padding */
        text-align: center;
        /* Center the text horizontally */
    }

    .bottom {
        font-size: 16px;
        /* Smaller font size for the text */
        padding: 5px 0;
        /* Adjust top and bottom padding */
        text-align: center;
        /* Center the text horizontally */
    }

    .la-name {
        font-size: 25px;
        /* Larger font size for emphasis */
        font-weight: bold;
        /* Bold font for the Local Authority name */
        color: #00aaff;
        padding: 3px 0;
        /* Add some padding above and below the text */
    }

    .la-summary {
        font-size: 16px;
        /* Slightly smaller font size than 'la-name' */
        color: #666;
        /* A lighter text color for the summary */
        padding-bottom: 10px;
        /* Add some padding below the text */
    }

    .service-table-name {
        width: 60%;
    }

    .service-table-provider {
        width: 30%;
    }

    .service-table-shelter {
        width: 10%;
        text-align: "center";
    }
</style>
<div class="container-fluid px-sm-5">
    <div class="alert alert-danger d-none" role="alert">Failed to retrieve the data. Please try again later.</div>

    <div class="row">
        <div class="col-12" style="padding-top:3px; padding-bottom:3px">
            <div class="chart-header d-flex align-items-center justify-content-between">
                <!-- Image and title container -->
                <div class="d-flex align-items-center">
                    <img alt="icon" class="chart-header-icon"
                        src="https://www.lhfatlas.org.uk/sites/default/files/images/accom_icon.png" />
                    <div class="chart-title">
                        <div class="chart-title-main">Young People's Services</div>
                        <div class="chart-title-sub"></div>
                        <div class="chart-intro">Source: Homeless Link information team. Hover over a borough on the map
                            for services,
                            click to bring up extra
                            detail.</div>
                    </div>
                </div>

            </div>
        </div>
    </div>



    <div class="rowq">
        <div class="column">
            <div class="top">109</div>
            <div class="bottom">services in London for 2024/25</div>
        </div>
        <div class="column">
            <div class="top">2,166</div>
            <div class="bottom">spaces in these services</div>
        </div>
    </div>


    <div class="row">
        <div class="col-12 col-lg-6">
            <div class="mt-2" id="specialist-health-service-map">&nbsp;</div>
        </div>

        <div class="col-12 col-lg-6">
            <div class="mt-2" id="specialist-health-service-list">&nbsp;</div>
        </div>
    </div>

    <div class="row">
        <div class="col-12">
            <div class="chart-footer">Copyright LHF Atlas 2025 - see <a href="https://www.lhfatlas.org.uk"
                    target="_blank">www.lhfatlas.org.uk</a> for full details</div>
        </div>
    </div>
</div>

<div class="chart-tooltip">&nbsp;</div>
<script src="https://d3js.org/d3.v5.min.js"></script>
<script src="https://d3js.org/d3-array.v2.min.js"></script>
<script src="https://code.jquery.com/jquery-3.5.1.slim.min.js"
    integrity="sha384-DfXdz2htPH0lsSSs5nCTpuj/zy4C+OGpamoFVy38MVBnE+IbbVYUew+OrCXaRkfj"
    crossorigin="anonymous"></script>
<script src="https://cdn.jsdelivr.net/npm/popper.js@1.16.1/dist/umd/popper.min.js"
    integrity="sha384-9/reFTGAW83EW2RDu2S0VKaIzap3H66lZH81PoYlFhbGU+6BZp6G7niu735Sk7lN"
    crossorigin="anonymous"></script>
<script src="https://stackpath.bootstrapcdn.com/bootstrap/4.5.2/js/bootstrap.min.js"
    integrity="sha384-B4gt1jrGC7Jh4AgTPSdUtOBvfO8shuf57BaghqFfPlYxofvL8/KUEfYiJOMMV+rV"
    crossorigin="anonymous"></script>
<script>
    function copyTextToClipboard(text) {
        var textArea = document.createElement("textarea");
        textArea.style.position = 'fixed';
        textArea.style.top = 0;
        textArea.style.left = 0;
        textArea.style.width = '2em';
        textArea.style.height = '2em';
        textArea.style.padding = 0;
        textArea.style.border = 'none';
        textArea.style.outline = 'none';
        textArea.style.boxShadow = 'none';
        textArea.style.background = 'transparent';
        textArea.value = text;
        document.body.appendChild(textArea);
        textArea.select();
        try {
            var successful = document.execCommand('copy');
            var msg = successful ? 'successful' : 'unsuccessful';
            console.log('Copying text command was ' + msg);
        } catch (err) {
            console.log('Oops, unable to copy');
        }

        document.body.removeChild(textArea);
    }

    function CopyURL() {
        copyTextToClipboard(location.href);
        alert("URL copied!");
    }

    function printPDF() {
        let chartRow = document.querySelector('.container-fluid');
        if (!chartRow) {
            console.error("Element '.container-fluid' not found.");
            return;
        }

        html2canvas(chartRow, { useCORS: true }).then(canvas => {
            try {
                let pdf = new jsPDF('l', 'mm', 'a4'); // landscape orientation
                let imgData = canvas.toDataURL('image/png');

                // Adjust the dimensions for landscape
                let pdfWidth = 297; // A4 width in mm
                let pdfHeight = 210; // A4 height in mm
                let imgWidth = canvas.width;
                let imgHeight = canvas.height;
                let ratio = Math.min(pdfWidth / imgWidth, pdfHeight / imgHeight);

                let newWidth = imgWidth * ratio;
                let newHeight = imgHeight * ratio;
                let xOffset = (pdfWidth - newWidth) / 2;
                let yOffset = (pdfHeight - newHeight) / 2;

                pdf.addImage(imgData, 'PNG', xOffset, yOffset, newWidth, newHeight);
                pdf.save('download.pdf');
            } catch (e) {
                console.error("Error generating PDF: ", e);
            }
        }).catch(error => {
            console.error("Error in html2canvas: ", error);
        });
    }

</script>
<script>
    (function () {

        const LONDON_GEO_URL = "https://raw.githubusercontent.com/illustrating-impact-dev/repo-lhf-atlas/main/data/boroughs.json";
        const SERVICES_TYPES_URL = "https://raw.githubusercontent.com/illustrating-impact-dev/repo-lhf-atlas/main/services_singlerow.json";
        const COLORS_URL = "https://raw.githubusercontent.com/illustrating-impact-dev/repo-lhf-atlas/main/data/lkp_hex_info.json";

        const TRANSITION_DURATION = 250;
        const LONDON_GSS = "E12000007";

        const selected = {
            serviceType: "Accommodation",
            borough: null,
            service: null,
        };

        const touchable = isTouchDevice();

        let data;

        const accessor = {
            services: {
                id: (d) => d.id,
                gssList: (d) => d["service_borough"].split(";"),
                serviceType: (d) => d.service_type,
                serviceName: (d) => d["service_name"],
                providerName: (d) => d.service_provider,
                website: (d) =>
                    d.URL_link && d.URL_link !== "None"
                        ? d.URL_link.slice(0, 4) !== "http"
                            ? `https://${d.URL_link}`
                            : d.URL_link
                        : null,
                serviceOffered: (d) => d["service_text_2"],
                spaces: (d) => d.shelter,
            },
            geo: {
                id: (d) => d.properties.GSS_CODE,
                name: (d) => d.properties.NAME,
            },
            colors: {
                key: (d) => d.colour_key,
                value: (d) => d.colour_value,
                color: (d) => `#${d.colour_hex}`,
            },
        };



        const dispatch = d3.dispatch("updatetop", "updatebottom");

        // Init
        const alert = setupAlert();
        const tooltip = renderTooltip(d3.select(".chart-tooltip"));

        Promise.all([
            d3.json(SERVICES_TYPES_URL),
            d3.json(LONDON_GEO_URL),
            d3.json(COLORS_URL),
        ])
            .then(([servicesTypes, london, colors]) => {
                data = processData(servicesTypes, london, colors);
                renderServicesTypes();
                renderServicesMap();
                renderServiceList();
                dispatch.call("updatetop");
                dispatch.call("updatebottom");
            })
            .catch((err) => {
                console.error(err);
                alert.show();
            });

        // Service types
        function renderServicesTypes() {
            const container = d3
                .select("#specialist-health-service-types")
                .classed(
                    "service-types row row-cols-1 row-cols-sm-2 row-cols-lg-3 row-cols-xl-4",
                    true
                );
            const serviceItemCard = container
                .selectAll(".col")
                .data(
                    Array.from(data.servicesByServiceType.entries())
                        .map(([serviceType, services]) => ({ serviceType, services }))
                        .sort((a, b) => d3.descending(a.services.length, b.services.length))
                )
                .join("div")
                .attr("class", "col mb-1")
                .append("div")
                .attr("class", "service-type-card card");
            const cardBody = serviceItemCard
                .append("div")
                .attr("class", "card-body pt-1 pb-2 px-2");
            const serviceTypeTitle = cardBody
                .append("div")
                .attr("class", "service-type-title mb-1")
                .text((d) => d.serviceType)
                .on("click", serviceTypeClicked);
            const serviceTile = cardBody
                .append("div")
                .attr("class", "service-tiles d-flex")
                .selectAll(".service-tile")
                .data((d) => d.services)
                .join("div")
                .attr("class", "service-tile")

            serviceTile.filter(accessor.services.website).on("click", clicked);

            dispatch.on("updatetop.service-types", () => {
                serviceItemCard.classed(
                    "active",
                    (d) => d.serviceType === selected.serviceType
                );
                serviceTile.classed("muted", (d) => {
                    if (selected.service) {
                        return accessor.services.id(d) !== selected.service;
                    } else if (selected.borough) {
                        if (accessor.services.serviceType(d) !== selected.serviceType)
                            return true;
                        const gssList = accessor.services.gssList(d);
                        return !(
                            gssList.includes(LONDON_GSS) || gssList.includes(selected.borough)
                        );
                    } else {
                        return false;
                    }
                });
            });

            function serviceTypeClicked(d) {
                if (d.serviceType === selected.serviceType) return;
                selected.serviceType = d.serviceType;
                dispatch.call("updatetop");
                dispatch.call("updatebottom");
            }

            function entered(d) {
                selected.service = accessor.services.id(d);
                selected.borough = null;
                dispatch.call("updatetop");
                tooltip.show(
                    serviceTooltipContent(d),
                    accessor.services.serviceType(d) === selected.serviceType
                        ? "#4e79a8"
                        : "#bab0ac"
                );
            }

            function left() {
                if (selected.service) {
                    selected.service = null;
                    dispatch.call("updatetop");
                }
                tooltip.hide();
            }

            function moved() {
                tooltip.move();
            }

            function clicked(d) {
                if (touchable || accessor.services.website(d) === "") return;
                window.open(accessor.services.website(d), "_blank");
            }
        }

        let highlightedGSS = "E09000033";

        // Services map
        function renderServicesMap() {
            let svgWidth, svgHeight;


            const margin = {
                top: 8,
                right: 8,
                bottom: 8,
                left: 8,
            };

            function createColorScale(data) {
                // Get all bed counts
                const bedCounts = Array.from(data.servicesByServiceTypeByBorough.get(selected.serviceType).values())
                    .map(services => services.reduce((sum, service) => sum + accessor.services.beds(service), 0));

                // Filter out zeros and sort remaining values
                const nonZeroBedCounts = bedCounts.filter(count => count > 0).sort((a, b) => a - b);

                // If we have no non-zero values, return a simple function that always returns the first color
                if (nonZeroBedCounts.length === 0) {
                    return d => '#f7fbff';
                }

                // Calculate quartiles for non-zero values
                const q1 = d3.quantile(nonZeroBedCounts, 0.25);
                const q2 = d3.quantile(nonZeroBedCounts, 0.5);
                const q3 = d3.quantile(nonZeroBedCounts, 0.75);
                const max = d3.max(nonZeroBedCounts);

                // Create a threshold scale
                return d3.scaleThreshold()
                    .domain([0.1, q1, q2, q3]) // Use 0.1 as the first threshold to separate 0 from non-zero values
                    .range(['#f7fbff', '#c6dbef', '#6baed6', '#2171b5', '#084594']);
            }

            // Replace the existing color scale with:
            const color = createColorScale(data);

            let projection = d3.geoMercator();
            let geoPath = d3.geoPath(projection);

            const container = d3
                .select("#specialist-health-service-map")
                .classed("service-map", true);
            const title = container
                .append("div")
                .attr("class", "service-map-title mb-2");
            const svg = container.append("svg");
            const borough = svg
                .append("g")
                .attr("class", "map-paths")
                .selectAll(".map-path")
                .data(data.london.features, (d) => {

                    return accessor.geo.id(d);
                })
                .join((enter) =>
                    enter
                        .append("path")
                        .attr("class", "map-path")
                        .attr("fill", "#fff")
                        .attr("data-gss-code", d => accessor.geo.id(d))
                        .classed("highlighted", (d) => accessor.geo.id(d) === highlightedGSS)
                        .on("mouseenter", entered)
                        .on("mouseleave", left)
                        .on("mousemove", moved)
                        .on("click", function (d) {
                            // Assuming d3.event is available in your D3 v5 setup
                            var event = d3.event;

                            // Access the GSS_CODE from the clicked path's data attribute
                            var clickedGSSCode = this.getAttribute("data-gss-code");

                            // Update the highlighted GSS based on the clicked element's GSS_CODE
                            highlightedGSS = clickedGSSCode;
                            dispatch.call("updatebottom");
                            // Update the 'highlighted' class for all paths based on the new highlightedGSS
                            d3.selectAll(".service-map .map-path")
                                .classed("highlighted", function (d) {
                                    return accessor.geo.id(d) === highlightedGSS;
                                });

                            // Move the newly highlighted path to the top
                            d3.selectAll(".service-map .map-path.highlighted").each(function () {
                                this.parentNode.appendChild(this);
                            });
                        })
                );

            borough.filter(".highlighted").each(function () {
                this.parentNode.appendChild(this);
            });


            const labels = svg
                .append("g")
                .attr("class", "map-labels")
                .selectAll(".map-label")
                .data(data.london.features)
                .join(enter =>
                    enter
                        .append("text")
                        .attr("class", "map-label")
                        .attr("text-anchor", "middle")
                        .attr("dy", ".35em")
                        .style("font-size", "10px")
                        .style("fill", "#000")
                        .style("pointer-events", "none")
                        .attr("transform", d => `translate(${geoPath.centroid(d)})`)
                );

            labels.append("tspan")
                .attr("class", "map-label-value")
                .text(d => {
                    const services = getBoroughServices(d);
                    const totalBeds = services.reduce((sum, service) =>
                        sum + accessor.services.beds(service), 0);
                    return totalBeds > 0 ? totalBeds : '';
                });


            const legend = container
                .append("div")
                .attr("class", "legend d-flex align-items-center");

            legend
                .append("div")
                .attr("class", "legend-title mr-4")
                .text("Number of spaces");



            // Create range labels
            const ranges = [
                '0',
                `1-${Math.round(color.domain()[1])}`,
                `${Math.round(color.domain()[1] + 1)}-${Math.round(color.domain()[2])}`,
                `${Math.round(color.domain()[2] + 1)}-${Math.round(color.domain()[3])}`,
                `${Math.round(color.domain()[3] + 1)}+`
            ];

            // Create legend items with ranges
            legend
                .selectAll(".legend-item")
                .data(ranges)
                .join("div")
                .attr("class", "legend-item d-flex justify-content-center align-items-center")
                .style("background-color", (d, i) => color.range()[i])
                .text(d => d);

            resize();
            window.addEventListener("resize", resize);



            // Update the labels positioning
            function updateLabels() {
                svg.selectAll(".map-label")
                    .attr("transform", d => {
                        const centroid = geoPath.centroid(d);
                        // Only show label if it has a valid centroid
                        if (isNaN(centroid[0]) || isNaN(centroid[1])) {
                            return "translate(-1000,-1000)"; // Move far off-screen if invalid
                        }
                        return `translate(${centroid[0]},${centroid[1]})`;
                    })
                    .style("display", d => {
                        const centroid = geoPath.centroid(d);
                        return isNaN(centroid[0]) || isNaN(centroid[1]) ? "none" : "block";
                    });
            }

            // Update the resize function to include label updates
            function resize() {
                svgWidth = container.node().clientWidth;
                svgHeight = Math.round((svgWidth / 390) * 300);

                projection.fitExtent(
                    [
                        [margin.left, margin.top],
                        [svgWidth - margin.right, svgHeight - margin.bottom],
                    ],
                    data.london
                );

                geoPath = d3.geoPath().projection(projection);
                svg.attr("width", svgWidth).attr("height", svgHeight);
                borough.attr("d", geoPath);

                // Update labels with new positions
                updateLabels();
            }

            dispatch.on("updatebottom.services-map", () => {
                title.text();

                borough
                    .transition()
                    .duration(TRANSITION_DURATION)
                    .attr("fill", (d) => {
                        const services = getBoroughServices(d);
                        const totalBeds = services.reduce((sum, service) =>
                            sum + accessor.services.beds(service), 0);
                        return color(totalBeds);
                    });

                borough.classed("muted", (d) => {
                    if (selected.service) {
                        const services = getBoroughServices(d);
                        const servicesIds = services.map(accessor.services.id);
                        return !servicesIds.includes(selected.service);
                    } else if (selected.borough) {
                        return accessor.geo.id(d) !== selected.borough;
                    } else {
                        return false;
                    }
                });
            });

            function entered(d) {
                const services = getBoroughServices(d);
                selected.borough = accessor.geo.id(d);
                selected.service = null;
                dispatch.call("updatebottom");

                // Create tooltip content for all boroughs, even those without services
                const tooltipContent = `
        <p class="borough-name">${accessor.geo.name(d)}</p>
        ${services.length > 0 ? `
        <ul class="list-unstyled mb-0">
            ${services.map((s) => `<li>${accessor.services.serviceName(s)}</li>`).join("")}
        </ul>
        ` : '<p>Borough did not report on Young People’s services in 2024/25</p>'}
    `;

                // Use appropriate color based on whether there are services
                const tooltipColor = services.length > 0 ? color(services.length) : '#6c757d';
                tooltip.show(tooltipContent, tooltipColor);
            }

            function left() {
                if (selected.borough) {
                    selected.borough = null;
                    dispatch.call("updatebottom");
                }
                tooltip.hide();
            }

            function moved() {
                tooltip.move();
            }

            function getBoroughServices(d) {
                const serviceByBorough = data.servicesByServiceTypeByBorough.get(
                    selected.serviceType
                );
                const gss = accessor.geo.id(d);
                const services = serviceByBorough.get(gss) || [];
                return services;
            }
        }

        // Service list
        function renderServiceList() {
            const container = d3
                .select("#specialist-health-service-list")
                .classed("service-list", true);

            // Add the new 'la-name' div above the title
            const laName = container
                .append("div")
                .attr("class", "la-name")
                .text("Islington"); // Set the text for 'la-name'

            // Add the new 'la-summary' div below 'la-name' and above the title
            const laSummary = container
                .append("div")
                .attr("class", "la-summary")
                .text("4 services with a total of 100 spaces"); // Set the text for 'la-summary'

            const title = container
                .append("div")
                .attr("class", "service-list-title mb-2");

            const serviceTableBody = container
                .append("table")
                .attr("class", "table table-hover table-sm")
                .append("tbody");

            dispatch.on("updatebottom.service-list", () => {
                const boroughFeature = data.london.features.find(d => accessor.geo.id(d) === highlightedGSS);
                const boroughName = boroughFeature ? accessor.geo.name(boroughFeature) : "Select a borough";

                laName.text(boroughName);

                // Get services and separate pan-London services
                let filteredServices = data.servicesByServiceType.get(selected.serviceType).filter(service => {
                    const gssList = accessor.services.gssList(service);
                    return gssList.includes(highlightedGSS) || gssList.includes("E12000007");
                });

                // Sort services to put pan-London at the bottom
                filteredServices.sort((a, b) => {
                    const aIsPanLondon = accessor.services.gssList(a).includes("E12000007");
                    const bIsPanLondon = accessor.services.gssList(b).includes("E12000007");
                    if (aIsPanLondon && !bIsPanLondon) return 1;
                    if (!aIsPanLondon && bIsPanLondon) return -1;
                    return 0;
                });

                const localServices = filteredServices.filter(s => !accessor.services.gssList(s).includes("E12000007"));
                const panLondonServices = filteredServices.filter(s => accessor.services.gssList(s).includes("E12000007"));

                const localBeds = localServices.reduce((acc, curr) => acc + accessor.services.beds(curr), 0);
                const panLondonBeds = panLondonServices.reduce((acc, curr) => acc + accessor.services.beds(curr), 0);

                if (filteredServices.length > 0) {
                    let summaryText = '';

                    // Add local services line if any exist
                    if (localServices.length > 0) {
                        const localServiceWord = localServices.length === 1 ? 'local service' : 'local services';
                        const localBedWord = localBeds === 1 ? 'space' : 'spaces';
                        summaryText += `${localServices.length} ${localServiceWord} with a total of ${localBeds} ${localBedWord}.`;
                    } else {
                        summaryText += 'Borough did not report on Young People’s services in 2024/25';
                    }

                    // Add pan-London services line if any exist
                    if (panLondonServices.length > 0) {
                        const panLondonServiceWord = panLondonServices.length === 1 ? 'service' : 'services';
                        const panLondonBedWord = panLondonBeds === 1 ? 'space' : 'spaces';
                        summaryText += `\nThere ${panLondonServices.length === 1 ? 'is' : 'are'} also ${panLondonServices.length} Pan-London ${panLondonServiceWord} with a total of ${panLondonBeds} ${panLondonBedWord}.`;
                    }

                    // Use HTML line break for proper formatting
                    laSummary.html(summaryText.replace('\n', '<br>'));
                } else {
                    laSummary.text("No services available in this borough");
                }

                // Create a new array that adds a divider between local and pan-London services if needed
                let combinedData = [];
                if (localServices.length > 0) {
                    combinedData = localServices.slice();
                }
                if (panLondonServices.length > 0) {
                    if (localServices.length > 0) {
                        // Insert a special divider row object
                        combinedData.push({ divider: true });
                    }
                    combinedData = combinedData.concat(panLondonServices);
                }

                // Update table: use the combinedData array.
                serviceTableBody
                    .selectAll("tr")
                    .data(combinedData, d => d.divider ? "divider" : accessor.services.id(d))
                    .join(
                        enter => enter.append("tr")
                            .each(function (d) {
                                let tr = d3.select(this);
                                if (d.divider) {
                                    // Render the divider row with one cell spanning all columns and a thick top border.
                                    tr.append("td")
                                        .attr("colspan", "3")
                                        .style("padding", "0")
                                        .style("border-top", "4px solid #000");
                                } else {
                                    // Render normal service rows exactly as before.
                                    tr.style("cursor", accessor.services.website(d) ? "pointer" : "default")
                                        .on("mouseenter", entered)
                                        .on("mouseleave", left)
                                        .on("mousemove", moved)
                                        .on("click", function (d) {
                                            if (accessor.services.website(d)) {
                                                window.open(accessor.services.website(d), "_blank");
                                            }
                                        });

                                    // Service name column with pan-London indicator
                                    tr.append("td")
                                        .html(function () {
                                            const isPanLondon = accessor.services.gssList(d).includes("E12000007");
                                            return `${accessor.services.serviceName(d)}${isPanLondon ? ' <span style="color: #42698f; font-style: italic">(Pan-London project)</span>' : ''}`;
                                        })
                                        .style("width", "50%");

                                    // Provider column
                                    tr.append("td")
                                        .text(() => accessor.services.providerName(d))
                                        .style("width", "40%");

                                    tr.append("td")
                                        .text(() => {
                                            const beds = accessor.services.beds(d);
                                            return beds === 0 ? "" : beds;
                                        })
                                        .style("width", "10%")
                                        .style("text-align", "center");
                                }
                            }),
                        update => update,
                        exit => exit.remove()
                    );
            });

            function clicked(d) {
                if (touchable || accessor.services.website(d) === "") return;
                window.open(accessor.services.website(d), "_blank");
            }

            function entered(d) {
                selected.service = accessor.services.id(d);
                selected.borough = null;
                dispatch.call("updatebottom");
                tooltip.show(serviceTooltipContent(d), "#4e79a8");
            }

            function left() {
                if (selected.service) {
                    selected.service = null;
                    dispatch.call("updatebottom");
                }
                tooltip.hide();
            }

            function moved() {
                tooltip.move();
            }
        }

        // Process data
        function processData(servicesTypes, london, colors) {

            const ACCOMMODATION_TYPE = "Accommodation";
            const SPECIAL_DAY_CENTRE_NAME = "New Horizon Youth Centre";
            const PAN_LONDON_CODE = "E12000007";

            servicesTypes = servicesTypes.filter(service =>
                service.service_type === ACCOMMODATION_TYPE && service.yp === true ||
                (service.service_type === "Day Centre" && service.service_name === SPECIAL_DAY_CENTRE_NAME)
            );

            servicesTypes.forEach(service => {
                if (service.service_type === "Day Centre" && service.service_name === SPECIAL_DAY_CENTRE_NAME) {
                    // Update the service type to match accommodation
                    service.service_type = ACCOMMODATION_TYPE;

                    // Ensure the service's borough list includes the pan-London code
                    const boroughs = service.service_borough.split(";");
                    if (!boroughs.includes(PAN_LONDON_CODE)) {
                        boroughs.push(PAN_LONDON_CODE);
                        service.service_borough = boroughs.join(";");
                    }
                }
            });
            // Continue with existing processing
            servicesTypes.forEach((d, i) => (d.id = i));
            const servicesById = d3.group(servicesTypes, accessor.services.id);

            const servicesByServiceType = d3.group(
                servicesTypes,
                accessor.services.serviceType
            );

            const allGSSs = london.features.map(accessor.geo.id);

            const servicesByServiceTypeByBorough = new Map();
            servicesByServiceType.forEach((values, serviceType) => {
                const servicesByBorough = new Map();
                values.forEach((d) => {
                    accessor.services.gssList(d).forEach((gss) => {
                        // Skip pan-London services for borough-specific counts
                        if (accessor.services.gssList(d).includes(LONDON_GSS)) {
                            return;
                        }

                        if (servicesByBorough.has(gss)) {
                            servicesByBorough.get(gss).push(d);
                        } else {
                            servicesByBorough.set(gss, [d]);
                        }
                    });
                });
                servicesByServiceTypeByBorough.set(serviceType, servicesByBorough);
            });

            colors = colors.filter((d) => accessor.colors.key(d) === 3);

            return {
                servicesById,
                servicesByServiceType,
                servicesByServiceTypeByBorough,
                london,
                colors,
            };
        }

        // Update accessor for beds
        accessor.services.beds = (d) => d.beds || 0;


        // Tooltip
        function renderTooltip(tooltip) {
            let width, height;
            const padding = 8;

            function show(content, color) {
                tooltip.style("border-color", color).html(content);
                const bcr = tooltip.node().getBoundingClientRect();
                width = bcr.width;
                height = bcr.height;
                tooltip.classed("show", true);
            }

            function hide() {
                tooltip.classed("show", false);
            }

            function move() {
                let x = d3.event.clientX - width / 2;
                if (x < 0) {
                    x = 0;
                } else if (x + width > window.innerWidth) {
                    x = window.innerWidth - width;
                }
                let y = d3.event.clientY - height - padding;
                if (y < 0) {
                    y = 0;
                }
                tooltip.style("transform", `translate(${x}px,${y}px)`);
            }

            return {
                show,
                hide,
                move,
            };
        }

        function boroughTooltipContent(d, services) {
            return `
      <p class="borough-name">${accessor.geo.name(d)}</p>
      <ul class="list-unstyled mb-0">
      ${services
                    .map((s) => `<li>${accessor.services.serviceName(s)}</li>`)
                    .join("")}
      </ul>
    `;
        }

        function serviceTooltipContent(d, color) {
            // Get the borough name from the first GSS code's corresponding borough
            const boroughList = accessor.services.gssList(d);
            const boroughText = boroughList.includes("E12000007") ? "Pan-London" : d.la_name || "Multiple boroughs";

            // Construct the content array with available information
            const contentParts = [];

            // Add service offered if available
            if (accessor.services.serviceOffered(d)) {
                contentParts.push(`<p>${accessor.services.serviceOffered(d)}</p>`);
            }

            // Add spaces/shelter capacity if available
            if (accessor.services.spaces(d)) {
                contentParts.push(`<p class="service-capacity">${accessor.services.spaces(d)} spaces</p>`);
            }

            // console.log(d.URL_link);
            // Check if URL exists and is valid
            const hasWebsite = d.URL_link && d.URL_link !== "None" && d.URL_link.trim() !== "";

            return `
        <p class="service-name">${accessor.services.serviceName(d)}</p>
        <p>Provided in <span>${boroughText}</span> by <span>${accessor.services.providerName(d)}</span></p>
        ${contentParts.join("")}
        ${hasWebsite ? `<p><em>${"Click to view service website"}</em></p>` : ""}
    `;
        }


        // Alert
        function setupAlert() {
            const alert = d3.select(".alert-danger");
            function show() {
                alert.classed("d-none", false);
            }
            function hide() {
                alert.classed("d-none", true);
            }
            return {
                show,
                hide,
            };
        }

        // Is touch
        // https://github.com/airbnb/is-touch-device/blob/master/src/index.js
        function isTouchDevice() {
            return (
                !!(
                    typeof window !== "undefined" &&
                    ("ontouchstart" in window ||
                        (window.DocumentTouch &&
                            typeof document !== "undefined" &&
                            document instanceof window.DocumentTouch))
                ) ||
                !!(
                    typeof navigator !== "undefined" &&
                    (navigator.maxTouchPoints || navigator.msMaxTouchPoints)
                )
            );
        }
    })();

</script>
<script>
    (function () {
        const CSV_LINKS_URL = "";

        const modalWidth = 320;

        d3.json(CSV_LINKS_URL).then((csvLinks) => {
            const modal = d3
                .select("body")
                .append("div")
                .attr("class", "modal fade")
                .attr("id", "csv-modal")
                .attr("tabindex", "-1");

            const modalDialog = modal
                .append("div")
                .attr("class", "modal-dialog m-0")
                .style("width", `${modalWidth}px`);

            const modalContent = modalDialog
                .append("div")
                .attr("class", "modal-content");

            const modalHeader = modalContent
                .append("div")
                .attr("class", "modal-header")
                .call((header) =>
                    header.append("h6").attr("class", "modal-title").text("CSV Download")
                )
                .call((header) =>
                    header
                        .append("button")
                        .attr("type", "button")
                        .attr("class", "close")
                        .attr("data-dismiss", "modal")
                        .attr("aria-label", "Close")
                        .append("span")
                        .attr("aria-hidden", "true")
                        .html("&times;")
                );

            const form = modalContent
                .append("div")
                .attr("class", "modal-body")
                .append("form");
            form
                .append("div")
                .attr("class", "form-group")
                .call((group) =>
                    group
                        .append("label")
                        .attr("for", "csv-source-select")
                        .text("Which data source would you like to download?")
                )
                .call((group) =>
                    group
                        .append("select")
                        .attr("class", "form-control custom-select custom-select-sm")
                        .attr("id", "csv-source-select")
                        .selectAll("option")
                        .data(csvLinks)
                        .join("option")
                        .attr("value", (d) => d.url)
                        .text((d) => d.name)
                );
            form
                .append("button")
                .attr("type", "submit")
                .attr("class", "btn btn-sm btn-primary")
                .text("Download")
                .on("click", downloadCSV);

            const csvButton = d3
                .select(".btn__export--csv")
                .attr("data-toggle", "modal")
                .attr("data-target", "#csv-modal");

            d3.select("body").append("style").text(`
      .modal-backdrop.show {
        opacity: 0.2;
      }
    `);

            const {
                width: buttonWidth,
                height: buttonHeight,
            } = csvButton.node().getBoundingClientRect();

            $("#csv-modal").on("show.bs.modal", positionModal);
            window.addEventListener("resize", resize);

            function downloadCSV() {
                d3.event.preventDefault();
                const url = d3.select("#csv-source-select").node().value;
                if (url) {
                    window.location = url;
                }
            }

            function positionModal() {
                let { left, top } = csvButton.node().getBoundingClientRect();
                left = left + buttonWidth / 2 - modalWidth / 2;
                if (left < 0) left = 0;
                if (left + modalWidth > window.innerWidth)
                    left = window.innerWidth - modalWidth;
                top = top + buttonHeight;
                modalDialog.style("left", `${left}px`).style("top", `${top}px`);
            }

            function resize() {
                if (modal.classed("show")) {
                    positionModal();
                }
            }
        });
    })();
</script>
<script>window.Choices = {}</script>